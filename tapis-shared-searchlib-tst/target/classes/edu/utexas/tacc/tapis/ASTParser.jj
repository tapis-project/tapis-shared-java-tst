/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ----------------------------------------------------------------------------
// OPTIONS
// ----------------------------------------------------------------------------
options {
  STATIC = false;
  UNICODE_INPUT = true;
  ERROR_REPORTING = true;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
  OUTPUT_DIRECTORY = "src/main/java/edu/utexas/tacc/tapis/search/parser";
}

// ----------------------------------------------------------------------------
// PARSER
// ----------------------------------------------------------------------------

PARSER_BEGIN(ASTParser)
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package edu.utexas.tacc.tapis.search.parser;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;
import java.lang.UnsupportedOperationException;

import edu.utexas.tacc.tapis.search.parser.Token;
import org.apache.commons.lang3.StringUtils;
import org.apache.activemq.filter.ConstantExpression;
import org.apache.activemq.util.LRUCache;

import edu.utexas.tacc.tapis.search.parser.ASTNode;
import edu.utexas.tacc.tapis.search.parser.ASTBinaryExpression;
import edu.utexas.tacc.tapis.search.parser.ASTUnaryExpression;
import edu.utexas.tacc.tapis.search.parser.ASTLeaf;

/*
 * DO NOTE EDIT
 * DO NOTE EDIT the .java file directly - it is autogenerated from ASTParser.jj
 * DO NOTE EDIT
 * Tapis AST parser generated by JavaCC
 * Based on JMS Selector Parser from ActiveMQ
 *
 * Map of Sql operators to Tapis operators
 *   =           -> EQ
 *   <>          -> NEQ
 *   <           -> LT
 *   <=          -> LTE
 *   >           -> GT
 *   >=          -> GTE
 *   LIKE        -> LIKE
 *   NOT LIKE    -> NLIKE
 *   BETWEEN     -> BETWEEN
 *   NOT BETWEEN -> NBETWEEN
 *   IN          -> IN
 *   NOT IN      -> NIN
 *
 * NOTES:
 *   - Specifying an escape character for LIKE is not supported.
 *   - String values must be surrounded by single quotes
 *   - Values for BETWEEN must be surrounded by single quotes
 *   - TODO/TBD: Following operations are not supported:
 *      IS NULL, IS NOT NULL
 *      Arithmetic operations (+, -, /, *, mod)
 *      Unary operators (-, NOT)
 */
public class ASTParser
{
  private static final Map<String, Object> cache = Collections.synchronizedMap(new LRUCache<>(100));

  public static ASTNode parse(String sql) throws UnsupportedOperationException
  {
    // Look for result in the cache
    Object result = cache.get(sql);
    // If result was an exception we are done
    if (result instanceof UnsupportedOperationException) { throw (UnsupportedOperationException) result; }
    // If we have already resolved the string to a node we are done
    else if (result instanceof ASTNode) { return (ASTNode) result; }
    else
    {
      // Result not in cache, convert sql string to a ASTNode
      try
      {
        // Recursive call to continue processing
        ASTNode node = new ASTParser(sql).parse();
        // Cache the result
        cache.put(sql, node);
        return node;
      }
      catch (UnsupportedOperationException t)
      {
        cache.put(sql, t);
        throw t;
      }
    }
  }

  public static void clearCache() { cache.clear(); }

  private String sql;

  protected ASTParser(String sql)
  {
    this(new StringReader(sql));
    this.sql = sql;
  }

  protected ASTNode parse() throws UnsupportedOperationException
  {
    // This kicks off execution of our grammar defined below
    // Variable sql contains the string to be processed
    try { return this.GetNode(); }
    catch (Throwable e) { throw new UnsupportedOperationException(sql, e); }
  }

  // ---------------------------------------------------------------------
  // Utility methods used by grammar to build ASTNode objects
  // ---------------------------------------------------------------------

  // ============================
  // conjunction / disjunction
  // ============================
  private ASTBinaryExpression createOR(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("OR", l, r);
  }
  private ASTBinaryExpression createAND(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("AND", l, r);
  }
  // ======================
  // equalityExpression()
  // ======================
  private ASTBinaryExpression createEqual(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("EQ", l, r);
  }
  private ASTBinaryExpression createNotEqual(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("NEQ", l, r);
  }
  // TODO/TBD: IS NULL is not the same as = null
  // TODO/TBD: Do not support IS NULL ?
  private ASTBinaryExpression createIsNull(ASTNode l)
  {
    return new ASTBinaryExpression("=", l, new ASTLeaf("NULL"));
  }
  // TODO/TBD: IS NOT NULL is not the same as <> null
  // TODO/TBD: Do not support IS NOT NULL ?
  private ASTBinaryExpression createIsNotNull(ASTNode l)
  {
    return new ASTBinaryExpression("<>", l, new ASTLeaf("NULL"));
  }
  // ======================
  // comparisonExpression()
  // ======================
  private ASTBinaryExpression createGreaterThan(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("GT", l, r);
  }
  private ASTBinaryExpression createGreaterThanEqual(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("GTE", l, r);
  }
  private ASTBinaryExpression createLessThan(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("LT", l, r);
  }
  private ASTBinaryExpression createLessThanEqual(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("LTE", l, r);
  }
  private ASTBinaryExpression createLike(ASTNode l, String s)
  {
    return new ASTBinaryExpression("LIKE", l, new ASTLeaf(s));
  }
  private ASTBinaryExpression createNotLike(ASTNode l, String s)
  {
    return new ASTBinaryExpression("NLIKE", l, new ASTLeaf(s));
  }
  private ASTBinaryExpression createBetween(ASTNode l, String low, String high)
  {
    String s = low + "," + high;
    return new ASTBinaryExpression("BETWEEN", l, new ASTLeaf(s));
  }
  private ASTBinaryExpression createNotBetween(ASTNode l, String low, String high)
  {
    String s = low + "," + high;
    return new ASTBinaryExpression("NBETWEEN", l, new ASTLeaf(s));
  }
  private ASTBinaryExpression createInList(ASTNode l, List<String> list)
  {
    StringJoiner sj = new StringJoiner(",");
    for (String s : list) { sj.add(s); }
    return new ASTBinaryExpression("IN", l, new ASTLeaf(sj.toString()));
  }
  private ASTBinaryExpression createNotInList(ASTNode l, List<String> list)
  {
    StringJoiner sj = new StringJoiner(",");
    for (String s : list) { sj.add(s); }
    return new ASTBinaryExpression("NIN", l, new ASTLeaf(sj.toString()));
  }
  // ======================
  // addExpression()
  // TODO/TBD: Do not support numeric operations?
  // ======================
  private ASTBinaryExpression createPlus(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("+", l, r);
  }
  private ASTBinaryExpression createMinus(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("-", l, r);
  }
  // ======================
  // multExpression()
  // TODO/TBD: Do not support numeric operations?
  // ======================
  private ASTBinaryExpression createMultiply(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("*", l, r);
  }
  private ASTBinaryExpression createDivide(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("/", l, r);
  }
  private ASTBinaryExpression createMod(ASTNode l, ASTNode r)
  {
    return new ASTBinaryExpression("%", l, r);
  }
  // ======================
  // unaryExpression()
  // TODO/TBD: Do not support unary operations?
  // ======================
  private ASTUnaryExpression createNegate(ASTNode n)
  {
    return new ASTUnaryExpression("-", n);
  }
  private ASTUnaryExpression createNOT(ASTNode n)
  {
    return new ASTUnaryExpression("NOT", n);
  }
}

PARSER_END(ASTParser)

// ----------------------------------------------------------------------------
// Tokens
// ----------------------------------------------------------------------------
/* White Space */
SPECIAL_TOKEN :
{
  " " | "\t" | "\n" | "\r" | "\f"
}

/* Comments */
SKIP:
{
  <LINE_COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP:
{
  <BLOCK_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/* Reserved Words */
TOKEN [IGNORE_CASE] :
{
    <  NOT     : "NOT">
  | <  AND     : "AND">
  | <  OR      : "OR">
  | <  BETWEEN : "BETWEEN">
  | <  LIKE    : "LIKE">
  | <  ESCAPE  : "ESCAPE">
  | <  IN      : "IN">
  | <  IS      : "IS">
  | <  TRUE    : "TRUE" >
  | <  FALSE   : "FALSE" >
  | <  NULL    : "NULL" >
}

/* Literals */
TOKEN [IGNORE_CASE] :
{
    < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* (["l","L"])? >
  | < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | < OCTAL_LITERAL: "0" (["0"-"7"])* >
  | < FLOATING_POINT_LITERAL:
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? // matches: 5.5 or 5. or 5.5E10 or 5.E10
        | "." (["0"-"9"])+ (<EXPONENT>)?              // matches: .5 or .5E10
        | (["0"-"9"])+ <EXPONENT>                     // matches: 5E10
    >
  | < #EXPONENT: "E" (["+","-"])? (["0"-"9"])+ >
  | < STRING_LITERAL: "'" ( ("''") | ~["'"] )*  "'" >
}

TOKEN [IGNORE_CASE] :
{
    < ID : ["a"-"z", "_", "$"] (["a"-"z","0"-"9","_", "$"])* >
}

// ----------------------------------------------------------------------------
// Grammar
// ----------------------------------------------------------------------------
ASTNode GetNode() :
{
    ASTNode left=null;
}
{
    left = orExpression() <EOF>
    {
        return left;
    }
}

ASTNode orExpression() :
{
    ASTNode left;
    ASTNode right;
}
{
    left = andExpression()
    (
        <OR> right = andExpression()
        {
            left = createOR(left, right);
        }
    )*
    {
        return left;
    }

}

ASTNode andExpression() :
{
    ASTNode left;
    ASTNode right;
}
{
    left = equalityExpression()
    (
        <AND> right = equalityExpression()
        {
            left = createAND(left, right);
        }
    )*
    {
        return left;
    }
}

ASTNode equalityExpression() :
{
    ASTNode left;
    ASTNode right;
}
{
    left = comparisonExpression()
    (

        "=" right = comparisonExpression()
        {
            left = createEqual(left, right);
        }
        |
        "<>" right = comparisonExpression()
        {
            left = createNotEqual(left, right);
        }
        |
        LOOKAHEAD(2)
        <IS> <NULL>
        {
            left = createIsNull(left);
        }
        |
        <IS> <NOT> <NULL>
        {
            left = createIsNotNull(left);
        }
    )*
    {
        return left;
    }
}

ASTNode comparisonExpression() :
{
    ASTNode left, right;
    String low, high, t;
    boolean not;
    ArrayList<String> list;
}
{
    left = addExpression()
    (

            ">" right = addExpression()
            {
                left = createGreaterThan(left, right);
            }
        |
            ">=" right = addExpression()
            {
                left = createGreaterThanEqual(left, right);
            }
        |
            "<" right = addExpression()
            {
                left = createLessThan(left, right);
            }
        |
            "<=" right = addExpression()
            {
                left = createLessThanEqual(left, right);
            }
       |
            <LIKE> t = stringLiteral()
            {
                left = createLike(left, t);
            }
       |
            LOOKAHEAD(2)
            <NOT> <LIKE> t = stringLiteral()
            {
                left = createNotLike(left, t);
            }
        |
            <BETWEEN> low = stringLiteral() <AND> high = stringLiteral()
            {
                left = createBetween(left, low, high);
            }
        |
            LOOKAHEAD(2)
            <NOT> <BETWEEN> low = stringLiteral() <AND> high = stringLiteral()
            {
                left = createNotBetween(left, low, high);
            }
        |
            <IN>
            "("
                t = stringLiteral()
                {
                    list = new ArrayList<>();
                    list.add( t );
                }
                (
                    ","
                    t = stringLiteral()
                    {
                        list.add( t );
                    }

                )*
            ")"
            {
               left = createInList(left, list);
            }
        |
            LOOKAHEAD(2)
            <NOT> <IN>
            "("
                t = stringLiteral()
                {
                    list = new ArrayList<>();
                    list.add( t );
                }
                (
                    ","
                    t = stringLiteral()
                    {
                        list.add( t );
                    }

                )*
            ")"
            {
               left = createNotInList(left, list);
            }

    )*
    {
        return left;
    }
}

ASTNode addExpression() :
{
    ASTNode left;
    ASTNode right;
}
{
    left = multExpr()
    (
        LOOKAHEAD( ("+"|"-") multExpr())
        (
            "+" right = multExpr()
            {
                left = createPlus(left, right);
            }
            |
            "-" right = multExpr()
            {
                left = createMinus(left, right);
            }
        )

    )*
    {
        return left;
    }
}

ASTNode multExpr() :
{
    ASTNode left;
    ASTNode right;
}
{
    left = unaryExpr()
    (
        "*" right = unaryExpr()
        {
            left = createMultiply(left, right);
        }
        |
        "/" right = unaryExpr()
        {
            left = createDivide(left, right);
        }
        |
        "%" right = unaryExpr()
        {
            left = createMod(left, right);
        }

    )*
    {
        return left;
    }
}

ASTNode unaryExpr() :
{
    String s=null;
    ASTNode left=null;
}
{
    (
        LOOKAHEAD( "+" unaryExpr() )
        "+" left=unaryExpr()
        |
        "-" left=unaryExpr()
        {
            left = createNegate(left);
        }
        |
        <NOT> left=unaryExpr()
        {
            left = createNOT(left);
        }
        |
        left = primaryExpr()
    )
    {
        return left;
    }

}

// For literals and <ID> this is the bottom for recursion
// A single sql of "a = 'b'" ends up here and calls idAsUnary
ASTNode primaryExpr() :
{
    ASTNode left=null;
}
{
    (
        left = literal()
        |
        left = idAsUnary()
        |
        "(" left = orExpression() ")"
    )
    {
        return left;
    }
}

ASTLeaf literal() :
{
    Token t;
    String s;
    ASTLeaf left=null;
}
{
    (
        (
            s = stringLiteral()
            {
                left = new ASTLeaf(s);
            }
        )
        |
        (
            t = <DECIMAL_LITERAL>
            {
                left = new ASTLeaf(ConstantExpression.createFromDecimal(t.image).toString());
            }
        )
        |
        (
            t = <HEX_LITERAL>
            {
                left = new ASTLeaf(ConstantExpression.createFromHex(t.image).toString());
            }
        )
        |
        (
            t = <OCTAL_LITERAL>
            {
                left = new ASTLeaf(ConstantExpression.createFromOctal(t.image).toString());
            }
        )
        |
        (
            t = <FLOATING_POINT_LITERAL>
            {
                left = new ASTLeaf(ConstantExpression.createFloat(t.image).toString());
            }
        )
        |
        (
            <TRUE>
            {
                left = new ASTLeaf("TRUE");
            }
        )
        |
        (
            <FALSE>
            {
                left = new ASTLeaf("FALSE");
            }
        )
        |
        (
            <NULL>
            {
                left = new ASTLeaf("NULL");
            }
        )
    )
    {
        return left;
    }
}

String stringLiteral() :
{
    Token t;
    StringBuilder rc = new StringBuilder();
    boolean first=true;
}
{
    t = <STRING_LITERAL>
    {
        // Decode the string value.
        String image = t.image;
        for( int i=1; i < image.length()-1; i++ ) {
            char c = image.charAt(i);
            if( c == '\'' )
                i++;
               rc.append(c);
        }
        return rc.toString();
    }
}

ASTUnaryExpression idAsUnary() :
{
    Token t;
}
{
    t = <ID>
    {
      return new ASTUnaryExpression("", new ASTLeaf(t.image));
    }
}
