package edu.utexas.tacc.tapis.shared.utils;

import java.util.ArrayList;

/** Adapted from the Code Project: https://www.codeproject.com/Articles/1076295/Base-Encode
 * 
 * This class encodes byte arrays into alphanumeric strings that contain only
 * upper and lower case ASCII letters and digits.  It also decodes previously
 * encoded strings back into byte arrays.  This is a non-standard encoding, so
 * strings encoded with this class must be decoded by this class to recover
 * the original byte array.
 * 
 * In addition to limiting encoding to alphanumerics, the encoding algorithm 
 * differs from standard base64 encoding by not padding.  The length of the 
 * encoded string depends not only on the number of input bytes, but also on 
 * their value.  The tradeoff is that different input values of the same
 * length can yield different length string encodings.  
 * 
 * For random input, this algorithm produces a string with length equal to or 
 * less than that produced by base64 encoding more than 90% of the time.  It 
 * also produces shorter strings than hex encoding well over 99% of the time 
 * for random input.  
 * 
 * The algorithm uses an escape character (CODEFLAG) to signal bit sequences
 * of value 61, 62 or 63.  In the worst case, when input bytes are sequences
 * of only these bit patterns, each 3 input bytes are encoded into 8 output 
 * characters.  This is worse than hex encoding, which always yields 2 
 * characters for each byte.
 * 
 * Usage
 * -----
 * The motivating use case for this class is password generation in which
 * randomly generated bytes are encoded into compact alphanumeric strings.
 * In this scenario, recovering the original bytes is not needed and
 * the average-case compactness of the encoded strings makes for easier 
 * handling.
 * 
 * This class is not appropriate for uses where a constant encoded string
 * length is required or where worst case inputs are likely. 
 * 
 * Implementation Revisions 
 * ------------------------
 * The original code was modified to improve comments, performance and 
 * interface consistency.  The public methods were made threadsafe.  The
 * main algorithm and bit manipulation code was not changed.  
 * 
 * @author John Jiyang Hou, revisions by rcardone
 */
public class Base62
{
    // Encoding alphabet.
    private static final String CODES =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    // Escape character.
    private static final char CODEFLAG = '9';
    
    // ASCII 65, 66, 67.
    private static final char[] CODEMAP = {'A', 'B', 'C'};        
    
    // This utility class never needs to be constructed.
    private Base62() {}
    
    // Write to encoded string.
    private static void Append(StringBuilder out, int b)
    {
        if(b < 61)
        {
            out.append(CODES.charAt(b));
        }
        else
        {                        
            // Output 9 + [A, B or C]
            out.append(CODEFLAG);
            out.append(CODES.charAt(b-61));
        }
    }    
    
    // ------ Public encoding method.
    public static String base62Encode(byte[] in)       
    {
        // Garbage in, garbage out.
        if (in == null) return null;
        
        // Create the output StringBuilder with capacity
        // sufficient in all but the most pathological cases.
        final StringBuilder out = new StringBuilder(in.length * 2);
        
        // Current byte temporary.
        int b;        
        
        // Loop with 3 bytes as a group
        for (int i = 0; i < in.length; i += 3) {
            
            // #1 char
            b = (in[i] & 0xFC) >> 2;                
            Append(out, b);
            
            b = (in[i] & 0x03) << 4;
            if (i + 1 < in.length) {
                
                // #2 char
                b |= (in[i + 1] & 0xF0) >> 4;
                Append(out, b);
                
                b = (in[i + 1] & 0x0F) << 2;
                if (i + 2 < in.length)  
                {
                    
                    // #3 char
                    b |= (in[i + 2] & 0xC0) >> 6;
                    Append(out, b);
                    
                    // #4 char
                    b = in[i + 2] & 0x3F;
                    Append(out, b);
                    
                }
                else  
                {         
                    // #3 char, last char
                    Append(out, b);                                        
                }
            }
            else
            {      
                // #2 char, last char
                Append(out, b);                
            }
        }

        return out.toString();
    }
    
    // ------ Public decoding method.
    public static byte[] base62Decode(String in)    
    {
        // Garbage in, garbage out.
        if (in == null) return null;
        
        // Work with character arrays.
        final char[] inChars = in.toCharArray();
        
        // Intermediate output list.
        ArrayList<Byte> decodedList = new ArrayList<Byte>();
        
        // 6 bits bytes
        int[] unit = new int[4];
        
        int inputLen = inChars.length;
        
        // char counter
        int n = 0;
        
        // unit counter
        int m = 0;
        
        // regular char
        char ch1 = 0;
        
        // special char
        char ch2 = 0;  
        
        // Temporary byte.
        Byte b = 0;
        
        while (n < inputLen)
        {            
            ch1 = inChars[n];
            if (ch1 != CODEFLAG)
            {
                // regular code                
                unit[m] = CODES.indexOf(ch1);
                m++;
                n++;
            }
            else
            {
                n++;
                if(n < inputLen)
                {
                    ch2 = inChars[n];
                    if(ch2 >= CODEMAP[0] && ch2 <= CODEMAP[2])
                    {
                        // special code index 61, 62, 63                                  
                        unit[m] = ch2 - 4;
                        m++;
                        n++;
                    }
                }
            }        
            
            // Add regular bytes with 3 bytes group composed from 4 units with 6 bits.
            if(m == 4)
            {                
                b = Byte.valueOf((byte) ((unit[0] << 2) | (unit[1] >> 4)));
                decodedList.add(b);
                b = Byte.valueOf((byte) ((unit[1] << 4) | (unit[2] >> 2)));
                decodedList.add(b);                    
                b = Byte.valueOf((byte) ((unit[2] << 6) | unit[3]));
                decodedList.add(b);
                
                // Reset unit counter
                m = 0;
            }
        }
        
        // Add tail bytes group less than 4 units
        if(m != 0)
        {
            if(m == 1)
            {
                b = Byte.valueOf((byte) ((unit[0] << 2) ));
                decodedList.add(b);
            }
            else if(m == 2)
            {
                b = Byte.valueOf((byte) ((unit[0] << 2) | (unit[1] >> 4)));
                decodedList.add(b);
            }
            else if (m == 3)
            {
                b = Byte.valueOf((byte) ((unit[0] << 2) | (unit[1] >> 4)));
                decodedList.add(b);
                b = Byte.valueOf((byte) ((unit[1] << 4) | (unit[2] >> 2)));
                decodedList.add(b);
            }
        }

        // Convert object Byte array to primitive byte array.
        byte[] decoded = new byte[decodedList.size()];
        for(int i = 0; i < decodedList.size(); i++) {
            decoded[i] = decodedList.get(i);
        }
        
        return decoded;
    }
}